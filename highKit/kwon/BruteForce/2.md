### 문제 설명

> 한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다.  
> 각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요.  

### 제한 사항

> numbers는 길이 1 이상 7 이하인 문자열입니다.  
> numbers는 0~9까지 숫자만으로 이루어져 있습니다.  
> "013"은 0, 1, 3 숫자가 적힌 종이 조각이 흩어져있다는 의미입니다.  

### 풀이 방법

> 정말 말 그대로 모든 경우의 수를 탐색해야 하는 완전 탐색 문제였다.  
> 각 숫자의 모든 조합을 생각해야 하기 때문에 permutation 함수를 이용한 순열로 접근하였다.  
> 단순히 permutation 함수를 쓰면 모든 조합을 도출할 수 없는데, 몇 가지 조건을 생각해야 했다.
>
> 1. 중복수는 탐색하지 않는데, 중복수가 나오는 경우는 두 자리 이상에서 맨 앞자리 수가 0인 경우이다.
> 2. 숫자의 갯수를 다르게 선택하는 경우가 있기 때문에, 0과 1로 만들어진 벡터를 생성해 순열을 돌리며 조합했다.
> 3. 두 가지 이상의 수를 선택했을 때, 다른 조합이 나올 수가 있어서 선택한 수에 대해서도 조합을 생각해야 한다.
> 4. 앞자리가 0이 아니어도 중복수가 발생할 수 있기 때문에, visited라는 벡터를 생성해 방문값을 저장해주었다.
> 5. 방문 여부를 따질 때 string을 int로 변환하여 해당 index의 값을 따졌다. 따라서 11과 011의 index는 같지만 순열 조합은 달라질 수 있기 때문에 내림차순으로 정렬해 prev_permutation을 사용했다.
> 
> 위의 조건을 생각해 순열을 조합했고, 에라토스테네스의 체를 이용해 소수 여부를 확인하여 값을 도출하였다.
