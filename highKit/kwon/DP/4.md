# 도둑질

https://programmers.co.kr/learn/courses/30/lessons/42897

## 문제 설명

도둑이 어느 마을을 털 계획을 하고 있습니다. 이 마을의 모든 집들은 아래 그림과 같이 동그랗게 배치되어 있습니다.

<img src = "https://grepp-programmers.s3.amazonaws.com/files/ybm/e7dd4f51c3/a228c73d-1cbe-4d59-bb5d-833fd18d3382.png" width = "400">

각 집들은 서로 인접한 집들과 방범장치가 연결되어 있기 때문에 인접한 두 집을 털면 경보가 울립니다.

각 집에 있는 돈이 담긴 배열 money가 주어질 때, 도둑이 훔칠 수 있는 돈의 최댓값을 return 하도록 solution 함수를 작성하세요.

## 제한 사항

- 이 마을에 있는 집은 3개 이상 1,000,000개 이하입니다.

- money 배열의 각 원소는 0 이상 1,000 이하인 정수입니다.

## 풀이 방법

인접한 지역은 털지 못하므로 i번째 집을 털 때의 최댓값은 i - 1번째와 i - 2번째를 확인하면 된다.

점화식을 세우면 ```dp[i] = max(dp[i - 1], dp[i - 2] + money[i])```가 될 것이다.

근데 집이 원형으로 배치돼있어 첫 번째 집과 마지막 집이 인접한 집이므로 두 가지 경우로 나눠야 한다.

첫 번째 집을 털고 최댓값을 구하는 경우와 첫 번째 집을 털지 않고 최댓값을 구하는 경우가 있는데,

첫 번째 집을 털었을 경우 ```dp[1] = 0```이 될 것이고, 털지 않았을 경우 ```dp[0] = 0```이 될 것이다.

그래서 나는 벡터를 두 개로 나눠 하나는 n - 2까지, 하나는 n - 1까지 반복문을 돌려 구했다.

근데 [10, 2, 2, 100, 2] 같은 테스트 케이스의 경우 위의 점화식대로 하면 두 번째 집인 2와 네 번째 집인 100을 선택해 결과값은 102가 되는데 실제 답은 110이다.

이런 케이스처럼 첫 번째 집을 선택하고 네 번째 집을 선택하는 경우도 있기 때문에 첫 번째 집의 점화식은

```dp[i] = max({dp[i - 1], dp[i - 2] + money[i], dp[i - 3] + money[i]})```가 된다.